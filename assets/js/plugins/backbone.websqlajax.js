/**
 * Backbone WebSQL Adapter + AJAX Syncing v0.0
 * 
 * Applications built upon the backbone boilerplate will generally
 * instantiate models in one of several ways:
 * -a fetch on a collection
 * -the id is provided (e.g. in the URL hash recognized by a router)
 * -the model is created by the user
 * 
 * Fetching on a collection:
 * my_class_collection = new Class.Collection();
 * my_class_collection.fetch(); //sets a success callback to collection.add/reset with the xhr (see below)
 * Backbone.WebSQLAjaxSync.call(my_class_collection, 'read', my_class_collection, options) //options.success contains above success callback
 * my_class_collection.store.findAll(my_class_collection, success, error) //success goes through the SQL result row-by-row, then the above success, then Backbone.ajaxQueue.prequeue(method,model,options)
 * my_class_collection.store._executeSql("SELECT COALESCE(id, local_id) as id, local_id, value, time_created, time_last_updated FROM "+ my_class_collection.store.tableName,[], success, error);
 * this.db.transaction(function(tx) {tx.executeSql(SQL, params, success, error);});
 * //Then the success callbacks.
 * Backbone.WebSQLAjaxSync.success(tx, res); //builds result row-by-row
 *  my_class_collection[options.add ? 'add' : 'reset'](my_class_collection.parse(result, xhr), options);
 *  Backbone.ajaxQueue.prequeue(method,model,options)
 * //Prequeue prepares the model(s) for remote sync (checks ids and association ids to make sure they are not local_ids)
 * //it sets the success callback, then sends it to the queue
 * this.queue(function(){return Backbone.sync(method, model, options);});
 * //If Backbone.sync is successful
 * iterate through remote objects, adding remote objects
 */

(function(window) {
	
	var S4 = function (){
		return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
	};
	var guid = function() {
		return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
	};
	var is_online = function () {
		if (navigator && navigator.onLine !== undefined) {
			return navigator.onLine;
		}
		try {
			var request = new XMLHttpRequest();
			request.open('GET', '/', false);
			request.send(null);
			return (request.status === 200);
		}
		catch(e) {
			return false;
		}
	};
	
	// Define the sync first. Then below define the store(s).
	// ====== [ Backbone.sync WebSQL implementation ] ======
	
	Backbone.WebSQLAjaxSync = function (method, model, options) {
		
		if (!model.store && !(model.collection && model.collection.store)){
			console.log("websqlajax sync specified but no store specified.");
		}
		
		var is_solo = !model.models;
		var store = model.store || model.collection.store, success, error;
		
		//Set the db request callbacks.
		var success = function (tx, res) {
			var len = res.rows.length,result=[], i, this_res;
			if (len > 0) {//res.rows is empty for anything except find or findall, I think.
				result = [];
				for (i=0;i<len;i++) {//Process each row from the SQL result and build an array of results.
					this_res = _.extend(JSON.parse(res.rows.item(i).value),res.rows.item(i));
					var tc = res.rows.item(i).time_created;
					var tlu = res.rows.item(i).time_last_updated;
					this_res.time_created = new Date(_.isString(tc) ? tc.replace(/-/g, "/") : tc).toISOString();//safari hacks
					this_res.time_last_updated = new Date(_.isString(tlu) ? tlu.replace(/-/g, "/") : tlu).toISOString();
					delete this_res.value;//value already in this_res root attributes
					result.push(this_res);//build the array.
				}
			}/* else if (is_solo && method == "read"){//We did a single-model find, but got no results.
				//Let the ajax fetch handle creating it in the local database.
			}*/
			//If the fetch/etc request came from a solo model, then the callback expects an object, not an array.
			if (is_solo && result.length==1) {result=result[0];}
			//Return the result of the initial WebSQL request to the app as quickly as possible by passing it as an argument to options.success
			//(options.success is the callback generated by Model (or Collection) .fetch)
			$.when(options.success(result)).then(
				//Only after the app has been updated should we then enqueue the Backbone.sync
				//Actually the queued up callback will do a little work on the model first before sending out the ajax sync request.
				Backbone.ajaxQueue.prequeue(method,model,options)
			);
		};
		
		var error = function (tx,error) {
			console.error("sql error");
			console.error(error);
			console.error(tx);
			options.error(error);//TODO: Does this work if there is more than 1 error callback?
		};
		
		/*
		 * TODO: In the case that the model has been created from a router, we will not
		 * yet know if it has already been persisted locally.
		 */
		
		//Send out the SQL request.
		switch(method) {
			case "read":
				if (!is_solo){//This is a collection.
					store.findAll(model, success, error);
				} else if (model.get("local_id") || model.id){
					//If we have a model.id or model.get("local_id"), then we might be able to find a match in the database.
					//We might only have id if the model was created from a router.
					//We might only have a local_id if it has not yet be synchronized.
					store.find(model, success, error);
				}
				break;
			case "create":
				store.create(model,success,error);
				break;
			case "update":
				store.update(model,success,error);
				break;
			case "delete":
				store.destroy(model,success,error);
				break;
			default:
				//console.log(method);
		}
	};
	
	var db = openDatabase("ultistats", "", "Leaguevine-ultistats db", 1024*1024*5);//5th parameter can be create callback.
	// ====== [ Default WebSQLStore ] ======
	// Use this store if you do not need a more specific store (see below).
	// Specify the store in the model definition.
	// store: new WebSQLStore(db, "model_name")
	Backbone.WebSQLStore = function (tableName, initSuccessCallback, initErrorCallback) {
		var success, error;
		this.tableName = tableName;
		this.db = db;
		success = function (tx,res) {
			if(initSuccessCallback) initSuccessCallback();
		};
		error = function (tx,error) {
			console.log("Error while create table",error);
			if (initErrorCallback) initErrorCallback();
		};
		db.transaction (function(tx) {
			tx.executeSql("CREATE TABLE IF NOT EXISTS " + tableName + 
				" (id UNIQUE, local_id UNIQUE, value, time_created INTEGER, time_last_updated INTEGER)",[],success, error);
			//local_id is used as .id in the app until the objected gets an id from the API.
			//local_id might also be used to find out real ids of associated objects.
		});
	};

	_.extend(Backbone.WebSQLStore.prototype,{
		
		create: function (model,success,error) {//Create might be called either by the API return or by the app making a new model.
			var real_id = (model.id && (model.id!=model.get("local_id") && ("" + model.id).indexOf("local_id")!=0));
			var local_id = guid();
			local_id = "local_id_" + local_id;
			model.set("local_id",local_id);
			
			var stmnt = "INSERT INTO " + this.tableName + " (";
			//var stmnt = "INSERT OR REPLACE INTO " + this.tableName + " (";//This will replace all of the db attributes with the passed attributes.
			var parms = [];
			
			if (real_id){
				stmnt += "id, ";
			}
			stmnt += "local_id, value, time_created, time_last_updated) VALUES (";
			
			if (real_id){
				stmnt += "?, ";
				parms.push(model.id);
			}
			stmnt += "?, ?";
			parms.push(model.get("local_id"));
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			parms.push(value);
			
			if (model.get("time_created")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_created")));//not necessary if create gives a result.
			} else {
				stmnt += ", datetime('now')";
				model.set("time_created", new Date().toISOString());//not necessary if create gives a result.
			}
			
			if (model.get("time_last_updated")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_last_updated")));
			} else {
				stmnt += ", datetime('now')";
				model.set("time_last_updated", new Date().toISOString());
			}
			stmnt += ")"
			
			this._executeSql(stmnt,parms, success, error);
		},
	
		destroy: function (model, success, error) {
			var real_id = (model.id && (model.id!=model.get("local_id") && ("" + model.id).indexOf("local_id")!=0));
			var stmnt = "DELETE FROM "+this.tableName+" WHERE local_id=?";
			var parms = [model.get("local_id")];
			if (real_id) {
				stmnt += " OR id = " + model.id;
			}
			this._executeSql(stmnt,parms,success, error);
		},
	
		find: function (model, success, error) {
			var real_id = (model.id && (model.id!=model.get("local_id") && ("" + model.id).indexOf("local_id")!=0));
			var stmnt = "SELECT COALESCE(id, local_id) AS id, local_id, value, time_created, time_last_updated FROM "+this.tableName+" WHERE ";
			var parms = [];
			if (model.get("local_id")){
				stmnt += "local_id=?";
				parms.push(model.get("local_id"));
			}
			if (real_id) {
				if (model.get("local_id")) { stmnt += " OR "; }
				stmnt += "id = " + model.id;
			}
			this._executeSql(stmnt, parms, success, error);
		},
	
		findAll: function (model, success,error) {
			//TODO: Handle the case when model has search criteria. This should be done in the model-specific store.
			this._executeSql("SELECT COALESCE(id, local_id) as id, local_id, value, time_created, time_last_updated FROM "+this.tableName,[], success, error);
		},
		
		update: function (model, success, error) {
			var real_id = (model.id && (model.id!=model.get("local_id") && ("" + model.id).indexOf("local_id")!=0));
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			
			//Build the statement and parms
			//this._executeSql("UPDATE "+this.tableName+" SET value=? WHERE id=?",[JSON.stringify(model.toJSON()),model.id], success, error);
			var stmnt = "UPDATE " + this.tableName + " SET value=?, time_last_updated=datetime('now')";
			var parms = [value]
			if (real_id) {
				stmnt += ", id = ";
				stmnt += "\"" + model.id + "\"";
			}
			stmnt += " WHERE local_id=?";
			parms.push(model.get("local_id"));
			if (real_id) {
				stmnt += " OR id = ";
				stmnt += "\"" + model.id + "\"";
			}
			this._executeSql(stmnt,parms, success, error);
		},
	
		_save: function (model, success, error) {
			//console.log("sql _save");
			var id = (model.id || model.attributes.id);
			this.db.transaction(function(tx) {
				tx.executeSql("");
			});
		},
	
		_executeSql: function (SQL, params, successCallback, errorCallback) {
			var success = function(tx,result) {
				//console.log(SQL + " - finished");
				if(successCallback) successCallback(tx,result);
			};
			var error = function(tx,error) {
				console.log(SQL + " - error: " + error);
				if(errorCallback) errorCallback(tx,error);
			};
			this.db.transaction(function(tx) {
				tx.executeSql(SQL, params, success, error);
			});
		}
	});
	
	// TODO: Create model-specific stores for improved performance.
	
	/*
	 * https://github.com/maccman/spine/blob/master/lib/ajax.js
	 * 
	 */
	Backbone.ajaxQueue = {
		requests: [],
		enabled: true,
		pending: false,
		disable: function(callback) {
			if (this.enabled) {
				this.enabled = false;
				try {
					return callback();
				} catch (e) {
					throw e;
				} finally {
					this.enabled = true;
				}
			} else {
				return callback();
			}
		},
		requestNext: function() {
			var next;
			next = this.requests.shift();
			if (next) {
				return this.request(next);
			} else {
				return this.pending = false;
			}
		},
		request: function(callback) {
			var _this = this;
			//if (is_online()) {
				return (callback()).then(function() {
					return _this.requestNext();
				});
			//} else {
				//this.requests.unshift(callback);
				//return setTimeout(this.requestNext(),10000);
			//}
		},
		queue: function(callback) {
			if (!this.enabled) {
				return;
			}
			if (this.pending) {
				this.requests.push(callback);
			} else {
				this.pending = true;
				this.request(callback);
			}
			return callback;
		},
		prequeue: function(method, model, options){
			/*
			 * Check to see if the model's associated ids are local_ids, and if so, try to update them.
			 * Clean the model.id and its associated ids so that none are local_ids.
			 * Set the success callback and then enqueue the object.
			 */
			
			/*
			 * TODO: model may or may not be alive in the app. If not, and it was persisted as JSON,
			 * then it won't be a model class so .set etc might not work.
			 * Is it possible to save the class name to the queue so that we can create a new model/collection on queue access? 
			 */
	 			
 			//Process associations. e.g., make sure that team.season_id is a real id and not a local_id.
 			if ((method=="create" || method=="update") && model.associations!==undefined && _.isObject(model.associations)){
 				var assoc = model.associations;
 				_.each(_.keys(assoc), function(this_key){
 					var table_name = assoc[this_key];
 					if (_.isString(model.get(this_key)) && model.get(this_key).indexOf("local_id")==0){
 						//The associated object has a local_id for id. We need to check table_name for its updated id.
 						var store = new Backbone.WebSQLStore(table_name);
 						var stmnt = "SELECT id FROM "+table_name+" WHERE local_id="+model.get(this_key);
 						//var stmnt = "SELECT COALESCE(id, local_id) AS id FROM "+table_name+" WHERE id="+model.get(this_key);
 						store._executeSql(stmnt,[], function(tx,result) {
 							if (result.rows.length>0){
 								//console.log("new id set");
 								model.set(this_key,result.rows.item(0).id);
 							}
						});
					}
 				});
 			}
 			
 			
			//Describe the success callback for when the ajax call returns.
	      	options.success = function(resp, status, xhr){
	      		/*
	      		 * This will be called after a successful ajax call to the API.
	      		 * We only expect a useful response if we're doing a fetch.
	      		 * TODO: Handle errors.
	      		 * TODO: Handle deleted object.
	      		 */
	      		
	      		//remote_objs might be an array or a single object. Make it always an array.
	      		remote_objs = model.parse(resp,xhr);
	      		if (remote_objs && !(remote_objs instanceof Array)){
	      			//model.id=remote_objs.id;//What does this do?
	      			remote_objs = [remote_objs];
      			}
      			
      			if (method=="create" && remote_objs.length==1) {
 					model.id = remote_objs[0].id;
 				}
	      		
      			//Iterate through remote_objs.
      			var matched_model; //use this to hold the in-app model that matches resp[x]
      			var models_to_add = [];//Build an array of models
      			_.each(remote_objs, function(remote_obj){//for each result from API
      				//Try to find a local model (either model, or a member of model.models) with a matching id.
      				matched_model = model.models ? model.get(remote_obj.id) : (model.id==remote_obj.id && model);
  					if (matched_model){//If the model was matched then merge data from matched_model and remote_obj
      					var remote_is_newer = true;//Assume remote is newer unless we have proof otherwise.
      					//Compare the dates, if remote_obj has dates.
      					if (remote_obj.time_created || remote_obj.time_last_updated){
      						var local_created = new Date(matched_model.get("time_created"));
      						var local_updated = new Date(matched_model.get("time_last_updated"));
      						var remote_created = new Date(remote_obj.time_created);
      						var remote_updated = new Date(remote_obj.time_last_updated);
      						var local_latest = Math.max.apply(null,[local_created,local_updated]);
      						remote_is_newer = isNaN(local_latest) || Math.max.apply(null,[remote_created,remote_updated]) >= local_latest;
      					}
      					if (remote_is_newer) {
      						matched_model.set(remote_obj, {silent: true});//Set all of the attributes.
      						if (matched_model.get("local_id") !== undefined) {//If this is already stored locally, it'll have a local_id
      							matched_model.store.update(matched_model, false, false);
      						} else {
      							matched_model.store.create(matched_model, false, false);
      						}
      					}
      				}
      				else {//We do not have a local model with matching id then create into the store
      					if (model.models) {//if this was a collection...
		      				var new_model = model._prepareModel(remote_obj, {});
		      				model.store.create(new_model,false,false);
		      				models_to_add.push(new_model);
		      			} else {//Under what circumstances would a single model do a fetch, and then get a response from the API that did not match?
		      				console.log("you should never see this text");
		      				var new_model = model.clone();
		      				new_model.clear({silent: true});
		      				new_model.set(remote_obj);
		      				model.store.create(new_model,false,false);
		      			}
	      			}
	      		});
	      		if (model.models && models_to_add.length>0) {
	      			model.add(models_to_add, {silent: true});
	      		}
		        model.trigger("reset", model);
      		};
      		this.queue(function(){
      			//A database call may have set model.id with local_id. If so, remove it here, because it'll confuse remote storage.
		      	if (model.id && (model.id==model.get("local_id") || ("" + model.id).indexOf("local_id")==0)) {
		      		model.unset(model.idAttribute, {silent: true});
	      		}
      			return Backbone.sync(method, model, options);
  			});
		}
	};
	
})(this);