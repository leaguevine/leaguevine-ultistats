/**
 * Backbone WebSQL Adapter + AJAX Syncing v0.0
 * 
 * Applications built upon the backbone boilerplate will generally
 * instantiate models in one of several ways:
 * -a fetch on a collection
 * -the id is provided (e.g. in the URL hash recognized by a router)
 * -the model is created by the user
 * 
 * Fetching on a collection:
 * my_class_collection = new Class.Collection();
 * my_class_collection.fetch(); //sets a success callback to collection.add/reset with the xhr (see below)
 * Backbone.WebSQLAjaxSync.call(my_class_collection, 'read', my_class_collection, options) //options.success contains above success callback
 * my_class_collection.store.findAll(my_class_collection, success, error) //success goes through the SQL result row-by-row, then the above success, then Backbone.ajaxQueue.prequeue(method,model,options)
 * my_class_collection.store._executeSql("SELECT COALESCE(id, local_id) as id, local_id, value, time_created, time_last_updated FROM "+ my_class_collection.store.tableName,[], success, error);
 * this.db.transaction(function(tx) {tx.executeSql(SQL, params, success, error);});
 * //Then the success callbacks.
 * Backbone.WebSQLAjaxSync.success(tx, res); //builds result row-by-row
 *  my_class_collection[options.add ? 'add' : 'reset'](my_class_collection.parse(result, xhr), options);
 *  Backbone.ajaxQueue.prequeue(method,model,options)
 * //Prequeue prepares the model(s) for remote sync (checks ids and association ids to make sure they are not local_ids)
 * //it sets the success callback, then sends it to the queue
 * this.queue(function(){return Backbone.sync(method, model, options);});
 * //If Backbone.sync is successful
 * iterate through remote objects, adding remote objects
 */

(function(window) {
	
	var S4 = function (){
		return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
	};
	var guid = function() {
		return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
	};
	var is_online = function () {
		if (navigator && navigator.onLine !== undefined) {
			return navigator.onLine;
		}
		try {
			var request = new XMLHttpRequest();
			request.open('GET', '/', false);
			request.send(null);
			return (request.status === 200);
		}
		catch(e) {
			return false;
		}
	};
	
	// Define the sync first. Then below define the store(s).
	// ====== [ Backbone.sync WebSQL implementation ] ======
	
	Backbone.WebSQLAjaxSync = function (method, model, options) {
		if (!model.store && !(model.collection && model.collection.store)){
			console.log("websqlajax sync specified but no store specified.");
		}
		
		var store = model.store || model.collection.store, success, error;
		
		//The following gets called whenever the initial db request returns.
		var success = function (tx, res) {
			
			//TODO: Why do we need an id?
			if (!model.id){model.id=model.get("local_id");}
			
			//res.rows is empty for anything except find or findall, I think.
			var len = res.rows.length,result=[], i, this_res;
			if (len > 0) {
				result = [];
				//Process each row from the SQL result and build an array of results.
				for (i=0;i<len;i++) {
					this_res = _.extend(JSON.parse(res.rows.item(i).value),res.rows.item(i));
					//.replace(/-/g, "/")
					var tc = res.rows.item(i).time_created;
					var tlu = res.rows.item(i).time_last_updated;
					this_res.time_created = new Date(_.isString(tc) ? tc.replace(/-/g, "/") : tc).toISOString();
					this_res.time_last_updated = new Date(_.isString(tlu) ? tlu.replace(/-/g, "/") : tlu).toISOString();
					delete this_res.value;
					result.push(this_res);
				}
			}
			//If the fetch/etc request came from a model, then the callback expects an object, not an array.
			if (!model.models && result.length==1) {result=result[0];}
			
			//Return the result of the initial WebSQL request to the app as quickly as possible by passing it as an argument to options.success
			//(options.success is the callback generated by Model (or Collection) .fetch)
			$.when(options.success(result)).then(
				//Only after the app has been updated should we then enqueue the Backbone.sync
				//Actually the queued up callback will do a little work on the model first before sending out the ajax sync request.
				Backbone.ajaxQueue.prequeue(method,model,options)
			);
		};
		
		var error = function (tx,error) {
			console.error("sql error");
			console.error(error);
			console.error(tx);
			options.error(error);//TODO: Does this work if there is more than 1 error callback?
		};
		
		/*
		 * Locally created models will have a local_id.
		 * Models that have been persisted remotely will have an id (happens during ajax success)
		 * But sometimes the model has not been created locally and not persisted remotely yet,
		 * and the application requires an id so we will have inserted our .local_id into .id
		 * We need to unset .id if it is actually from local_id so other methods don't think this
		 * has been persisted remotely.
		 */
		if (model.id && model.id==model.get("local_id")) {
			model.unset(model.idAttribute, {silent: true});
		}
		
		/*
		 * In the case that the model has been created from a router, we will not
		 * yet know if it has already been persisted locally. We can do a SELECT to
		 * find it, but if it does not exist then we should create it.
		 */
		
		//Send out the SQL request.
		switch(method) {
			case "read":
				((model.id || model.get("local_id")) ? store.find(model,success,error) : store.findAll(model, success, error));
				break;
			case "create":
				model.set("time_created",new Date().toISOString());
  				model.set("time_last_updated",new Date().toISOString());
				store.create(model,success,error);
				break;
			case "update":
				store.update(model,success,error);
				break;
			case "delete":
				store.destroy(model,success,error);
				break;
			default:
				//console.log(method);
		}
	};
	
	var db = openDatabase("ultistats", "", "Leaguevine-ultistats db", 1024*1024*5);//5th parameter can be create callback.
	// ====== [ Default WebSQLStore ] ======
	// Use this store if you do not need a more specific store (see below).
	// Specify the store in the model definition.
	// store: new WebSQLStore(db, "model_name")
	Backbone.WebSQLStore = function (tableName, initSuccessCallback, initErrorCallback) {
		var success, error;
		this.tableName = tableName;
		this.db = db;
		success = function (tx,res) {
			if(initSuccessCallback) initSuccessCallback();
		};
		error = function (tx,error) {
			console.log("Error while create table",error);
			if (initErrorCallback) initErrorCallback();
		};
		db.transaction (function(tx) {
			//local_id will be used until object is created in API
			//and local_id will later be used to look up the real id for associations.
			tx.executeSql("CREATE TABLE IF NOT EXISTS " + tableName + 
				" (id UNIQUE, local_id UNIQUE, value, time_created INTEGER, time_last_updated INTEGER)",[],success, error);
		});
	};

	_.extend(Backbone.WebSQLStore.prototype,{
		//model.id will have been stripped if model.id is the same as local_id
		create: function (model,success,error) {
			//Create might be called either by the API return or by the app making a new model.
			var local_id = guid();
			local_id = "local_id_" + local_id;
			model.set("local_id",local_id);
			
			var stmnt = "INSERT INTO " + this.tableName + " (";
			var parms = [];
			
			if (model.id){
				stmnt += "id, ";
			}
			stmnt += "local_id, value, time_created, time_last_updated) VALUES (";
			
			if (model.id){
				stmnt += "?, ";
				parms.push(model.id);
			}
			stmnt += "?, ?";
			parms.push(model.get("local_id"));
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			parms.push(value);
			
			if (model.get("time_created")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_created")));
			} else {stmnt += ", datetime('now')";}
			
			if (model.get("time_last_updated")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_last_updated")));
			} else {stmnt += ", datetime('now')";}
			stmnt += ")"
			
			if (!model.id){model.id=local_id;} //If we don't have an id, set it to be the local_id
			//console.log(model.id);
			this._executeSql(stmnt,parms, success, error);
		},
	
		destroy: function (model, success, error) {
			//console.log("sql destroy");
			var stmnt = "DELETE FROM "+this.tableName+" WHERE local_id=?";
			var parms = [model.get("local_id")];
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt,parms,success, error);
		},
	
		find: function (model, success, error) {
			//model will have been stripped of id if it matches local_id
			var stmnt = "SELECT COALESCE(id, local_id) AS id, local_id, value, time_created, time_last_updated FROM "+this.tableName+" WHERE local_id=?";
			var parms = [model.get("local_id")];
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt, parms, success, error);
		},
	
		findAll: function (model, success,error) {
			//console.log("sql findAll");
			//TODO: Handle the case when model has search criteria. This should be done in the model-specific store.
			this._executeSql("SELECT COALESCE(id, local_id) as id, local_id, value, time_created, time_last_updated FROM "+this.tableName,[], success, error);
			//this._executeSql("SELECT id, value FROM "+this.tableName,[], success, error);			
		},
	
		update: function (model, success, error) {
			//console.log("sql update")
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			
			//Build the statement and parms
			//this._executeSql("UPDATE "+this.tableName+" SET value=? WHERE id=?",[JSON.stringify(model.toJSON()),model.id], success, error);
			var stmnt = "UPDATE " + this.tableName + " SET value=?, time_last_updated=datetime('now')";
			var parms = [value]
			if (model.id) {
				stmnt += ", id=?";
				parms.push(model.id);
			}
			stmnt += " WHERE local_id=?";
			parms.push(model.get("local_id"));
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt,parms, success, error);
		},
	
		_save: function (model, success, error) {
			//console.log("sql _save");
			var id = (model.id || model.attributes.id);
			this.db.transaction(function(tx) {
				tx.executeSql("");
			});
		},
	
		_executeSql: function (SQL, params, successCallback, errorCallback) {
			var success = function(tx,result) {
				//console.log(SQL + " - finished");
				if(successCallback) successCallback(tx,result);
			};
			var error = function(tx,error) {
				console.log(SQL + " - error: " + error);
				if(errorCallback) errorCallback(tx,error);
			};
			this.db.transaction(function(tx) {
				tx.executeSql(SQL, params, success, error);
			});
		}
	});
	
	// TODO: Create model-specific stores for improved performance.
	
	/*
	 * https://github.com/maccman/spine/blob/master/lib/ajax.js
	 * 
	 */
	Backbone.ajaxQueue = {
		requests: [],
		enabled: true,
		pending: false,
		disable: function(callback) {
			if (this.enabled) {
				this.enabled = false;
				try {
					return callback();
				} catch (e) {
					throw e;
				} finally {
					this.enabled = true;
				}
			} else {
				return callback();
			}
		},
		requestNext: function() {
			var next;
			next = this.requests.shift();
			if (next) {
				return this.request(next);
			} else {
				return this.pending = false;
			}
		},
		request: function(callback) {
			var _this = this;
			//if (is_online()) {
				return (callback()).then(function() {
					return _this.requestNext();
				});
			//} else {
				//this.requests.unshift(callback);
				//return setTimeout(this.requestNext(),10000);
			//}
		},
		queue: function(callback) {
			if (!this.enabled) {
				return;
			}
			if (this.pending) {
				this.requests.push(callback);
			} else {
				this.pending = true;
				this.request(callback);
			}
			return callback;
		},
		prequeue: function(method, model, options){
			/*
			 * Check to see if the model's associated ids are local_ids, and if so, try to update them.
			 * Clean the model.id and its associated ids so that none are local_ids.
			 * Set the success callback and then enqueue the object.
			 */
			
			
			/*
			 * TODO: model may or may not be alive in the app. If not, and it was persisted as JSON,
			 * then it won't be a model class so .set etc might not work.
			 * Is it possible to save the class name to the queue so that we can create a new model/collection on queue access? 
			 */
	 			
 			//Process associations. e.g., make sure that team.season_id is a real id and not a local_id.
 			if ((method=="create" || method=="update") && model.associations!==undefined && _.isObject(model.associations)){
 				var assoc = model.associations;
 				_.each(_.keys(assoc), function(this_key){
 					var table_name = assoc[this_key];
 					if (_.isString(model.get(this_key)) && model.get(this_key).indexOf("local_id")==0){
 						//The associated object has a local_id for id. We need to check table_name for its updated id.
 						var store = new Backbone.WebSQLStore(table_name);
 						//var stmnt = "SELECT COALESCE(id, local_id) AS id FROM "+table_name+" WHERE local_id="+model.get(this_key);
 						var stmnt = "SELECT COALESCE(id, local_id) AS id FROM "+table_name+" WHERE id="+model.get(this_key);
 						store._executeSql(stmnt,[], function(tx,result) {
 							if (result.rows.length>0){
 								//console.log("new id set");
 								model.set(this_key,result.rows.item(0).id);
 							}
						});
					}
 				});
 			}
 			
 			//Remove any local_id from the model before syncing with remote.
	      	if (model.id && (model.id==model.get("local_id") || ("" + model.id).indexOf("local_id")==0)) {model.unset(model.idAttribute, {silent: true});}
	      	
	      	
			//Describe the success callback when the API call returns.
	      	//TODO: Handle errors.
	      	options.success = function(resp, status, xhr){
	      		//TODO: Handle delete.
	      		//Replace the success callback.
	      		//merge attributes, set last_updated, and save merged version in local db
	      		remote_objs = model.parse(resp,xhr);
	      		//remote_objs might be an array or a single object. Make it always an array.
	      		if (remote_objs && !(remote_objs instanceof Array)){
	      			model.id=remote_objs.id;//Useful for create method's return
	      			remote_objs = [remote_objs];
      			}
      			
      			//iterate through remote_objs. Probably only works for fetch
      			var matched_model;
      			var models_to_add = [];
      			_.each(remote_objs, function(remote_obj){//for each result from API
      				//Try to find a local model (either model, or a member of model.models) with a matching id.
      				matched_model = model.models ? model.get(remote_obj.id) : (model.id==remote_obj.id && model);
  					if (matched_model){//If the model was matched then merge data from matched_model and remote_obj
      					var remote_is_newer = true;//Assume remote is newer unless we have proof otherwise.
      					//Compare the dates, if remote_obj has dates.
      					if (remote_obj.time_created || remote_obj.time_last_updated){
      						var local_created = new Date(matched_model.get("time_created"));
      						var local_updated = new Date(matched_model.get("time_last_updated"));
      						var remote_created = new Date(remote_obj.time_created);
      						var remote_updated = new Date(remote_obj.time_last_updated);
      						var local_latest = Math.max.apply(null,[local_created,local_updated]);
      						remote_is_newer = isNaN(local_latest) || Math.max.apply(null,[remote_created,remote_updated]) >= local_latest;
      					}
      					if (remote_is_newer) {
      						matched_model.set(remote_obj);//Set all of the attributes. fires "change"
      						if (model.get("local_id" !== undefined)) {//If this is already stored locally, it'll have a local_id
      							model.store.update(matched_model);
      						} else {
      							model.store.create(matched_model, false, false);
      						}
      					}
      				}
      				else {//We do not have a local model with matching id then create into the store
      					if (model.models) {//if this was a collection...
		      				var new_model = model._prepareModel(remote_obj, {});
		      				if (!(remote_obj.time_created || remote_obj.time_last_updated)){
		      					new_model.set("time_created", new Date().toISOString());
		      					new_model.set("time_last_updated", new Date().toISOString());
		      				}
		      				models_to_add.push(new_model);
		      			} else {//Under what circumstances would a single model do a fetch, and then get a response from the API that did not match?
		      				console.log("you should never see this text");
		      				new_model = model.clone();
		      				new_model.clear({silent: true});
		      				new_model.set(remote_obj);
		      			}
		      			model.store.create(new_model,false,false);
	      			}
	      		});
	      		if (model.models && models_to_add.length>0) {
	      			model.add(models_to_add, {silent: true});
	      		}
		        model.trigger("reset");
      		};
      		this.queue(function(){return Backbone.sync(method, model, options);});
		}
	};
	
})(this);