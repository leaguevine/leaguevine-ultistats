/**
 * Backbone WebSQL Adapter + AJAX Syncing v0.0
 */

(function(window) {
	
	var S4 = function (){
		return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
	};
	var guid = function() {
		return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
	};
	var is_online = function () {
		if (navigator && navigator.onLine !== undefined) {
			return navigator.onLine;
		}
		try {
			var request = new XMLHttpRequest();
			request.open('GET', '/', false);
			request.send(null);
			return (request.status === 200);
		}
		catch(e) {
			return false;
		}
	};
	
	// Define the sync first. Then below define the store(s).
	// ====== [ Backbone.sync WebSQL implementation ] ======
	
	Backbone.WebSQLAjaxSync = function (method, model, options) {
		if (!model.store && !(model.collection && model.collection.store)){
			console.log("websqlajax sync specified but no store specified.");
		}
		
		var store = model.store || model.collection.store, success, error;
		
		//The following gets called whenever the initial db request returns.
		var success = function (tx, res) {
			
			if (!model.id){model.id=model.get("local_id");}
			
			//res.rows is empty for anything except find or findall, I think.
			var len = res.rows.length,result=[], i, this_res;
			if (len > 0) {
				result = [];
				//Process each row from the SQL result and build an array of results.
				for (i=0;i<len;i++) {
					this_res = _.extend(JSON.parse(res.rows.item(i).value),res.rows.item(i));
					this_res.time_created = new Date(res.rows.item(i).time_created).toISOString();
					this_res.time_last_updated = new Date(res.rows.item(i).time_last_updated).toISOString();
					delete this_res.value;
					result.push(this_res);
				}
			}
			//If the fetch/etc request came from a model, then the callback expects an object, not an array.
			if (!model.models && result.length==1) {result=result[0];}
			
			//Return the result of the initial WebSQL request to the app as quickly as possible by passing it as an argument to options.success
			//(options.success is the callback generated by Model (or Collection) .fetch)
			$.when(options.success(result)).then(
				//Only after the app has been updated should we then enqueue the Backbone.sync
				//Actually the queued up callback will do a little work on the model first before sending out the ajax sync request.
				Backbone.ajaxQueue.prequeue(method,model,options)
			);
		};
		
		var error = function (tx,error) {
			console.error("sql error");
			console.error(error);
			console.error(tx);
			options.error(error);//TODO: Does this work if there is more than 1 error callback?
		};
		
		//Before we send the SQL statement and the above callbacks, we need to clean up the model.
		//The model's .id might be a local_id if it was created locally, we need to make sure it exists only as model.get("local_id")
		if (!model.models && model.id && !model.has("local_id") && model.id.indexOf("local_id") ==0){model.set("local_id",model.id);}
		if (model.id && model.id==model.get("local_id")) {model.unset(model.idAttribute, {silent: true});}
		
		//Send out the SQL request.
		switch(method) {
			case "read":
				((model.id || model.get("local_id")) ? store.find(model,success,error) : store.findAll(model, success, error));
				break;
			case "create":
				model.set("time_created",new Date().toISOString());
  				model.set("time_last_updated",new Date().toISOString());
				store.create(model,success,error);
				break;
			case "update":
				store.update(model,success,error);
				break;
			case "delete":
				store.destroy(model,success,error);
				break;
			default:
				//console.log(method);
		}
	};
	
	var db = openDatabase("ultistats", "", "Leaguevine-ultistats db", 1024*1024*5);//5th parameter can be create callback.
	// ====== [ Default WebSQLStore ] ======
	// Use this store if you do not need a more specific store (see below).
	// Specify the store in the model definition.
	// store: new WebSQLStore(db, "model_name")
	Backbone.WebSQLStore = function (tableName, initSuccessCallback, initErrorCallback) {
		var success, error;
		this.tableName = tableName;
		this.db = db;
		success = function (tx,res) {
			if(initSuccessCallback) initSuccessCallback();
		};
		error = function (tx,error) {
			console.log("Error while create table",error);
			if (initErrorCallback) initErrorCallback();
		};
		db.transaction (function(tx) {
			//local_id will be used until object is created in API
			//and local_id will later be used to look up the real id for associations.
			tx.executeSql("CREATE TABLE IF NOT EXISTS " + tableName + 
				" (id INTEGER UNIQUE, local_id UNIQUE, value, time_created INTEGER, time_last_updated INTEGER)",[],success, error);
		});
	};

	_.extend(Backbone.WebSQLStore.prototype,{
		//model.id will have been stripped if model.id is the same as local_id
		create: function (model,success,error) {
			//Create might be called either by the API return or by the app making a new model.
			var local_id = guid();
			local_id = "local_id_" + local_id;
			model.set("local_id",local_id);
			
			var stmnt = "INSERT INTO " + this.tableName + " (";
			var parms = [];
			
			if (model.id){
				stmnt += "id, ";
			}
			stmnt += "local_id, value, time_created, time_last_updated) VALUES (";
			
			if (model.id){
				stmnt += "?, ";
				parms.push(model.id);
			}
			stmnt += "?, ?";
			parms.push(model.get("local_id"));
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			parms.push(value);
			
			if (model.get("time_created")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_created")));
			} else {stmnt += ", datetime('now')";}
			
			if (model.get("time_last_updated")){
				stmnt += ", ?";
				parms.push(Date.parse(model.get("time_last_updated")));
			} else {stmnt += ", datetime('now')";}
			stmnt += ")"
			
			if (!model.id){model.id=local_id;}
			//console.log(model.id);
			this._executeSql(stmnt,parms, success, error);
		},
	
		destroy: function (model, success, error) {
			//console.log("sql destroy");
			var stmnt = "DELETE FROM "+this.tableName+" WHERE local_id=?";
			var parms = [model.get("local_id")];
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt,parms,success, error);
		},
	
		find: function (model, success, error) {
			//console.log("sql find");
			//model will have been stripped of id if it matches local_id
			//There may be times when we have id but not local_id?
			var stmnt = "SELECT COALESCE(id, local_id) AS id, local_id, value, time_created, time_last_updated FROM "+this.tableName+" WHERE local_id=?";
			var parms = [model.get("local_id")];
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt, parms, success, error);
		},
	
		findAll: function (model, success,error) {
			//console.log("sql findAll");
			//TODO: Handle the case when model has search criteria. This should be done in the model-specific store.
			this._executeSql("SELECT COALESCE(id, local_id) as id, local_id, value, time_created, time_last_updated FROM "+this.tableName,[], success, error);
			//this._executeSql("SELECT id, value FROM "+this.tableName,[], success, error);			
		},
	
		update: function (model, success, error) {
			//console.log("sql update")
			//Clean id, local_id, time_created, and time_last_updated from the stringified version of the model, as those will be stored in separate columns.
			var value = model.toJSON();
			delete value.id;
			delete value.local_id;
			delete value.time_created;
			delete value.time_last_updated;
			value = JSON.stringify(value);
			
			//Build the statement and parms
			//this._executeSql("UPDATE "+this.tableName+" SET value=? WHERE id=?",[JSON.stringify(model.toJSON()),model.id], success, error);
			var stmnt = "UPDATE " + this.tableName + " SET value=?, time_last_updated=datetime('now')";
			var parms = [value]
			if (model.id) {
				stmnt += ", id=?";
				parms.push(model.id);
			}
			stmnt += " WHERE local_id=?";
			parms.push(model.get("local_id"));
			if (model.id) {
				stmnt += " OR id=?";
				parms.push(model.id);
			}
			this._executeSql(stmnt,parms, success, error);
		},
	
		_save: function (model, success, error) {
			//console.log("sql _save");
			var id = (model.id || model.attributes.id);
			this.db.transaction(function(tx) {
				tx.executeSql("");
			});
		},
	
		_executeSql: function (SQL, params, successCallback, errorCallback) {
			var success = function(tx,result) {
				//console.log(SQL + " - finished");
				if(successCallback) successCallback(tx,result);
			};
			var error = function(tx,error) {
				console.log(SQL + " - error: " + error);
				if(errorCallback) errorCallback(tx,error);
			};
			this.db.transaction(function(tx) {
				tx.executeSql(SQL, params, success, error);
			});
		}
	});
	
	// TODO: Create model-specific stores for improved performance.
	
	/*
	 * https://github.com/maccman/spine/blob/master/lib/ajax.js
	 * 
	 */
	Backbone.ajaxQueue = {
		requests: [],
		enabled: true,
		pending: false,
		disable: function(callback) {
			if (this.enabled) {
				this.enabled = false;
				try {
					return callback();
				} catch (e) {
					throw e;
				} finally {
					this.enabled = true;
				}
			} else {
				return callback();
			}
		},
		requestNext: function() {
			var next;
			next = this.requests.shift();
			if (next) {
				return this.request(next);
			} else {
				return this.pending = false;
			}
		},
		request: function(callback) {
			var _this = this;
			return (callback()).then(function() {
				return _this.requestNext();
			});
		},
		queue: function(callback) {
			if (!this.enabled) {
				return;
			}
			if (this.pending) {
				this.requests.push(callback);
			} else {
				this.pending = true;
				this.request(callback);
			}
			return callback;
		},
		prequeue: function(method, model, options){
			//TODO: model may or may not be alive in the app. If not, and it was persisted as JSON, 
 			//then it won't be a model class so .set etc might not work.
 			//Is it possible to save the class name to the queue so that we can create a new model/collection on queue access?
	 			
 			//TODO: Process associations. e.g., make sure that team.season_id is a real id and not a local_id.
 			if (method=="create" || method=="update"){
 				console.log("TODO: Process model's associations");
 			}
 			
 			//Remove any local_id from the model before syncing with remote.
	      	if (model.id && (model.id==model.get("local_id") || ("" + model.id).indexOf("local_id")==0)) {model.unset(model.idAttribute, {silent: true});}
			//Describe the success callback when the API call returns.
	      	//TODO: Handle errors.
	      	options.success = function(resp, status, xhr){
	      		//TODO: Handle delete.
	      		//Replace the success callback.
	      		//merge attributes, set last_updated, and save merged version in local db
	      		remote_objs = model.parse(resp,xhr);
	      		//remote_objs might be an array or a single object. Make it always an array.
	      		if (remote_objs && !(remote_objs instanceof Array)){
	      			model.id=remote_objs.id;//Useful for create method's return
	      			remote_objs = [remote_objs];
      			}
      			
      			//iterate through remote_objs. How many remote_objs do we get for methods that aren't fetch?
      			var was_added = false; //used below to make sure we trigger 'reset' if any models have been added.
      			var matched_model;
      			_.each(remote_objs, function(remote_obj){//for each result from API
      				//Do we have a local model with a matching id?
      				if (matched_model = model.models ? model.get(remote_obj.id) : (model.id==remote_obj.id && model)) {
      					//Assume remote is newer unless we have proof otherwise.
      					var local_is_newer = false;
      					//Compare the dates, if remote_obj has dates.
      					if (remote_obj.time_created || remote_obj.time_last_updated){
      						var local_created = new Date(matched_model.get("time_created"));
      						var local_updated = new Date(matched_model.get("time_last_updated"));
      						var remote_created = new Date(remote_obj.time_created);
      						var remote_updated = new Date(remote_obj.time_last_updated);
      						local_is_newer = Math.max.apply(null,[local_created,local_updated]) > Math.max.apply(null,[remote_created,remote_updated]);
      					}
      					if (local_is_newer) {
      						console.log("TODO: merge matched_model onto remote_obj");
      						//Don't merge id.
      					}
      					matched_model.set(remote_obj);
	      				model.store.update(matched_model);
      				} else {//We do not have a local model with matching id then create into the store
      					if (model.models) {
		      				var new_model = model._prepareModel(remote_obj, {});
		      				new_model.set("time_created", new Date().toISOString());
		      				new_model.set("time_last_updated", new Date().toISOString());
		      				//add to the collection.
		      				if (model.models.length>0 && !was_added) {
		      					model.add(remote_obj);
		      				}
		      				else {
		      					model.add(remote_obj,{silent: true});
		      					was_added = true;
		      				}
		      				
		      			} else {
		      				//Under what circumstances would a single model do a fetch, and then get a response from the API that did not match?
		      				console.log("you should never see this text");
		      				new_model = model.clone();
		      				new_model.clear({silent: true});
		      				new_model.set(remote_obj);
		      			}
		      			model.store.create(new_model,false,false);
	      			}
	      		});
		        model.trigger("reset");
	      		//else {model.set(remote_model);}
      		};
      		this.queue(function(){return Backbone.sync(method, model, options);});
		}
	};
	
})(this);